import hashlib
import logging
import subprocess
import uuid
from enum import Enum
from typing import Optional, Union, Tuple

import click
from fastapi import FastAPI

from ted_sws.event_manager.adapters.logger import Logger, LOG_INFO_LEVEL
from ted_sws.event_manager.domain.message_bus import message_bus
from ted_sws.event_manager.model.message import Log


class ResponseType(Enum):
    JSON = "json"
    RAW = "raw"


class UUIDInputProcessType(Enum):
    MD5 = "md5"
    RAW = "raw"


class UUIDNamespaceType(Enum):
    DNS = "DNS"
    URL = "URL"
    OID = "OID"
    X500 = "X500"


API_SERVER_LOG_LEVELS: Tuple = ('critical', 'error', 'warning', 'info', 'debug', 'trace')

app = FastAPI()


@click.command()
@click.option('-h', '--host', default="localhost")
@click.option('-p', '--port', default=8000, type=int)
@click.option('-l', '--log-level', default="info", type=click.Choice(API_SERVER_LOG_LEVELS))
def api_server_start(host, port, log_level):
    logger = Logger(name="API_SERVER", level=LOG_INFO_LEVEL)
    fmt = "[%(asctime)s] - %(name)s - %(levelname)s:\n%(message)s"
    date_fmt = "%Y-%m-%d %H:%M:%S"
    logger_formatter = logging.Formatter(fmt, date_fmt)
    logger.add_stdout_handler(formatter=logger_formatter)
    log_level_text = f" --log-level {log_level}" if log_level else ""
    bash_script = f"uvicorn --host {host} --port {port}{log_level_text} ted_sws.core.entrypoints.api.main:app --reload"
    message_bus.handle(Log(
        message=f"{bash_script}\n###\nSee http://{host}:{port}/docs for API usage.\n###",
        logger=logger)
    )
    subprocess.run(bash_script, shell=True, capture_output=True)


def single_result_response(result: str, response_type: ResponseType) -> Union[str, dict]:
    """
    Returns RAW or JSON response, based on requested response_type
    :param result:
    :param response_type:
    :return:
    """
    if response_type == ResponseType.JSON:
        return {"result": result}
    else:
        return result


def string_md5(value: str):
    """
    Generates MD5 hash, based on provided value
    :param value:
    :return:
    """
    return hashlib.md5(value.encode('utf8')).hexdigest()


@app.get("/fn/md5/{value}")
async def fn_md5(value: str, response_type: Optional[ResponseType] = ResponseType.RAW):
    """
    Returns a hash generated by the MD5 message digest algorithm, taking as arguments:
    - @value: string value to be hashed;
    - @response_type: response type/format to be returned;
    """
    result = string_md5(value)
    return single_result_response(result, response_type)


def uuid_ns_by_type(ns_type: UUIDNamespaceType) -> uuid.UUID:
    """
    Returns UUID Namespace Value to be used when generating the UUID string, based on provided Namespace Type
    :param ns_type:
    :return:
    """
    uuid_ns: uuid.UUID = uuid.NAMESPACE_DNS
    if ns_type == UUIDNamespaceType.URL:
        uuid_ns = uuid.NAMESPACE_URL
    elif ns_type == UUIDNamespaceType.OID:
        uuid_ns = uuid.NAMESPACE_OID
    elif ns_type == UUIDNamespaceType.X500:
        uuid_ns = uuid.NAMESPACE_X500
    return uuid_ns


@app.get("/fn/uuid/{value}")
async def fn_uuid(
        value: str,
        input_process_type: Optional[UUIDInputProcessType] = UUIDInputProcessType.RAW,
        ns_type: Optional[UUIDNamespaceType] = UUIDNamespaceType.DNS,
        response_type: Optional[ResponseType] = ResponseType.RAW
):
    """
    Returns generated UUID, taking as arguments:
    - @value: string value to be hashed;
    - @input_process_type: algorithm used to process @value before generating UUID string;
    - @ns_type: namespace type to be used when generating UUID string;
    - @response_type: response type/format to be returned;
    """
    if input_process_type != UUIDInputProcessType.RAW:
        value = string_md5(value)

    result = str(uuid.uuid5(uuid_ns_by_type(ns_type), value))
    return single_result_response(result, response_type)
